<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title>Chapter 13 -- Configuration Files and Persistence</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<style type="text/css">

/* example stylesheet for Docutils */

/* :Author:    Günter Milde */
/* :Copyright: © 2012 G. Milde */
/* :License:   This stylesheet is placed in the public domain. */

/* Syntax highlight rules for HTML documents generated with Docutils */
/* using the ``--syntax-highlight=long`` option (new in v. 0.9). */

/* This stylesheet implements Pygment's "default" style with less rules than */
/* pygments-default using class hierarchies.                                 */
/* Use it as example for "handcrafted" styles with only few rules.      */

.code                              { background: #f8f8f8; }
.code .comment                     { color: #008800; font-style: italic }
.code .error                       { border: 1px solid #FF0000 }
.code .generic.deleted             { color: #A00000 }
.code .generic.emph                { font-style: italic }
.code .generic.error               { color: #FF0000 }
.code .generic.heading             { color: #000080; font-weight: bold }
.code .generic.inserted            { color: #00A000 }
.code .generic.output              { color: #808080 }
.code .generic.prompt              { color: #000080; font-weight: bold }
.code .generic.strong              { font-weight: bold }
.code .generic.subheading          { color: #800080; font-weight: bold }
.code .generic.traceback           { color: #0040D0 }
.code .keyword                     { color: #AA22FF; font-weight: bold }
.code .keyword.pseudo              { font-weight: normal }
.code .literal.number              { color: #666666 }
.code .literal.string              { color: #BB4444 }
.code .literal.string.doc          { color: #BB4444; font-style: italic }
.code .literal.string.escape       { color: #BB6622; font-weight: bold }
.code .literal.string.interpol     { color: #BB6688; font-weight: bold }
.code .literal.string.other        { color: #008000 }
.code .literal.string.regex        { color: #BB6688 }
.code .literal.string.symbol       { color: #B8860B }
.code .name.attribute              { color: #BB4444 }
.code .name.builtin                { color: #AA22FF }
.code .name.class                  { color: #0000FF }
.code .name.constant               { color: #880000 }
.code .name.decorator              { color: #AA22FF }
.code .name.entity                 { color: #999999; font-weight: bold }
.code .name.exception              { color: #D2413A; font-weight: bold }
.code .name.function               { color: #00A000 }
.code .name.label                  { color: #A0A000 }
.code .name.namespace              { color: #0000FF; font-weight: bold }
.code .name.tag                    { color: #008000; font-weight: bold }
.code .name.variable               { color: #B8860B }
.code .operator                    { color: #666666 }
.code .operator.word               { color: #AA22FF; font-weight: bold }

</style>
<style type="text/css">

/* Page layout tweaks */
div.document { width: 6in; }

</style>
</head>
<body>
<div class="document" id="chapter-13-configuration-files-and-persistence">
<h1 class="title">Chapter 13 -- Configuration Files and Persistence</h1>

<!-- #!/usr/bin/env python3 -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#locations" id="id1">1&nbsp;&nbsp;&nbsp;Locations</a></li>
<li><a class="reference internal" href="#ini-files" id="id2">2&nbsp;&nbsp;&nbsp;INI files</a></li>
<li><a class="reference internal" href="#py-files" id="id3">3&nbsp;&nbsp;&nbsp;PY files</a><ul class="auto-toc">
<li><a class="reference internal" href="#top-level-v1" id="id4">3.1&nbsp;&nbsp;&nbsp;Top-level -- v1</a></li>
<li><a class="reference internal" href="#top-level-v2" id="id5">3.2&nbsp;&nbsp;&nbsp;Top-level -- v2</a></li>
<li><a class="reference internal" href="#top-level-v3" id="id6">3.3&nbsp;&nbsp;&nbsp;Top-level -- v3</a></li>
<li><a class="reference internal" href="#execfile-import" id="id7">3.4&nbsp;&nbsp;&nbsp;Execfile Import</a></li>
</ul>
</li>
<li><a class="reference internal" href="#chainmap-and-import" id="id8">4&nbsp;&nbsp;&nbsp;ChainMap and Import</a></li>
<li><a class="reference internal" href="#json-or-yaml-files" id="id9">5&nbsp;&nbsp;&nbsp;JSON or YAML files</a><ul class="auto-toc">
<li><a class="reference internal" href="#yaml" id="id10">5.1&nbsp;&nbsp;&nbsp;YAML</a></li>
</ul>
</li>
<li><a class="reference internal" href="#property-files" id="id11">6&nbsp;&nbsp;&nbsp;Property files</a></li>
<li><a class="reference internal" href="#xml-files" id="id12">7&nbsp;&nbsp;&nbsp;XML files</a><ul class="auto-toc">
<li><a class="reference internal" href="#plist" id="id13">7.1&nbsp;&nbsp;&nbsp;Plist</a></li>
<li><a class="reference internal" href="#non-plist" id="id14">7.2&nbsp;&nbsp;&nbsp;Non-Plist</a></li>
</ul>
</li>
</ul>
</div>
<pre class="literal-block">
from simulation_model import *
</pre>
<p>A typical main program using the above class definitions</p>
<pre class="literal-block">
import csv
def simulate_blackjack():
    dealer_rule= Hit17()
    split_rule= NoReSplitAces()
    table= Table( decks=6, limit=50, dealer=dealer_rule,
        split=split_rule, payout=(3,2) )
    player_rule= SomeStrategy()
    betting_rule= Flat()
    player= Player( play=player_rule, betting=betting_rule, rounds=100, stake=50 )
    simulator= Simulate( table, player, samples=100 )
    with open(&quot;p2_c13_simulation.dat&quot;,&quot;w&quot;,newline=&quot;&quot;) as results:
        wtr= csv.writer( results )
        for gamestats in simulator:
            wtr.writerow( gamestats )

def check( filename ):
    with open(filename,&quot;r&quot;,newline=&quot;&quot;) as results:
        rdr= csv.reader( results )
        outcomes= ( float(row[10]) for row in rdr )
        first= next(outcomes)
        sum_0, sum_1 = 1, first
        value_min = value_max = first
        for value in outcomes:
            sum_0 += 1 # value**0
            sum_1 += value # value**1
            value_min= min( value_min, value )
            value_max= max( value_max, value )
        mean= sum_1/sum_0
        print( &quot;{4}\nMean = {0:.1f}\nHouse Edge = {1:.1%}\nRange = {2:.1f} {3:.1f}&quot;.format(mean, 1-mean/50, value_min, value_max, filename) )

if __name__ == &quot;__main__&quot;:
    simulate_blackjack()
    check( &quot;p2_c13_simulation.dat&quot; )
</pre>
<div class="section" id="locations">
<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;Locations</a></h1>
<p>Tyical list of locations for config</p>
<pre class="literal-block">
import os
def location_list( config_name= &quot;someapp.config&quot; ):
    config_locations = (
        os.path.expanduser(&quot;~thisapp/&quot;), # or thisapp.__file__,
        &quot;/etc&quot;,
        os.path.expanduser(&quot;~/&quot;),
        os.path.curdir,
    )
    candidates = ( os.path.join(dir,config_name)
        for dir in config_locations )
    config_names = [ name for name in candidates if os.path.exists(name) ]
    return config_names
</pre>
</div>
<div class="section" id="ini-files">
<h1><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;INI files</a></h1>
<p>Sample INI files</p>
<pre class="literal-block">
import io
ini_file= io.StringIO( &quot;&quot;&quot;
; Default casino rules
[table]
    dealer= Hit17
    split= NoResplitAces
    decks= 6
    limit= 50
    payout= (3,2)

; Player with SomeStrategy
[player]
    play= SomeStrategy
    betting= Flat
    rounds= 100
    stake= 50

[simulator]
    samples= 100
    outputfile= p2_c13_simulation1.dat
&quot;&quot;&quot; )

ini2_file= io.StringIO( &quot;&quot;&quot;
; Need to compare with OtherStrategy
[player]
    play= OtherStrategy
    betting= Flat
    rounds= 100
    stake= 50

[simulator]
    samples= 100
    outputfile= p2_c13_simulation1a.dat
&quot;&quot;&quot; )
</pre>
<p>Using the config to build objects</p>
<pre class="literal-block">
def main_ini( config ):
    dealer_nm= config.get('table','dealer', fallback='Hit17')
    dealer_rule= {'Hit17':Hit17(),
        'Stand17':Stand17()}.get(dealer_nm, Hit17())
    split_nm= config.get('table','split', fallback='ReSplit')
    split_rule= {'ReSplit':ReSplit(),
        'NoReSplit':NoReSplit(),
        'NoReSplitAces':NoReSplitAces()}.get(split_nm, ReSplit())
    decks= config.getint('table','decks', fallback=6)
    limit= config.getint('table','limit', fallback=100)
    payout= eval( config.get('table','payout', fallback='(3,2)') )
    table= Table( decks=decks, limit=limit, dealer=dealer_rule,
        split=split_rule, payout=payout )

    player_nm= config.get('player','play', fallback='SomeStrategy')
    player_rule= {'SomeStrategy':SomeStrategy(),
        'AnotherStrategy':AnotherStrategy()}.get(player_nm,SomeStrategy())
    bet_nm= config.get('player','betting', fallback='Flat')
    betting_rule= {'Flat':Flat(),
        'Martingale':Martingale(),
        'OneThreeTwoSix':OneThreeTwoSix()}.get(bet_nm,Flat())
    rounds= config.getint('player','rounds', fallback=100)
    stake= config.getint('player','stake', fallback=50)
    player= Player( play=player_rule, betting=betting_rule,
        rounds=rounds, stake=stake )

    outputfile= config.get('simulator', 'outputfile', fallback='blackjack.csv')
    samples= config.getint('simulator', 'samples', fallback=100)
    simulator= Simulate( table, player, samples=samples )
    with open(outputfile,&quot;w&quot;,newline=&quot;&quot;) as results:
        wtr= csv.writer( results )
        for gamestats in simulator:
            wtr.writerow( gamestats )
</pre>
<p>Sample Main Script to parse and start the application.</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    import configparser
    config = configparser.ConfigParser()
    config.read_file(ini_file)
    config.read_file(ini2_file)

    # Could use config.read_string( text ), also
    # When there are multiple candidate locations, config.read( location_list(&quot;blackjack.ini&quot;) )

    for name, section in config.items():
        print( name )
        for p in config.items(name):
            print( &quot; &quot;, p )

    main_ini(config)

    check( config.get('simulator', 'outputfile') )
</pre>
</div>
<div class="section" id="py-files">
<h1><a class="toc-backref" href="#id3">3&nbsp;&nbsp;&nbsp;PY files</a></h1>
<div class="section" id="top-level-v1">
<h2><a class="toc-backref" href="#id4">3.1&nbsp;&nbsp;&nbsp;Top-level -- v1</a></h2>
<p>Imported Stuff from some application module.</p>
<pre class="literal-block">
import csv
def simulate( table, player, outputfile, samples ):
    simulator= Simulate( table, player, samples=samples )
    with open(outputfile,&quot;w&quot;,newline=&quot;&quot;) as results:
        wtr= csv.writer( results )
        for gamestats in simulator:
            wtr.writerow( gamestats )
</pre>
<p>Configuration in the main script</p>
<p><tt class="docutils literal">from simulator import *</tt></p>
<pre class="literal-block">
def simulate_SomeStrategy_Flat():
    dealer_rule= Hit17()
    split_rule= NoReSplitAces()
    table= Table( decks=6, limit=50, dealer=dealer_rule,
        split=split_rule, payout=(3,2) )
    player_rule= SomeStrategy()
    betting_rule= Flat()
    player= Player( play=player_rule, betting=betting_rule, rounds=100, stake=50 )
    simulate( table, player, &quot;p2_c13_simulation3.dat&quot;, 100 )

if __name__ == &quot;__main__&quot;:
    simulate_SomeStrategy_Flat()
    check(&quot;p2_c13_simulation3.dat&quot;)
</pre>
</div>
<div class="section" id="top-level-v2">
<h2><a class="toc-backref" href="#id5">3.2&nbsp;&nbsp;&nbsp;Top-level -- v2</a></h2>
<p>Stuff imported from some application module</p>
<p><tt class="docutils literal">from simulator import *</tt></p>
<pre class="literal-block">
class Default_App:
    pass

def simulate_c( config ):
    simulator= Simulate( config.table, config.player, config.samples )
    with open(config.outputfile,&quot;w&quot;,newline=&quot;&quot;) as results:
        wtr= csv.writer( results )
        for gamestats in simulator:
            wtr.writerow( gamestats )
</pre>
<p>Configuration in the main script</p>
<pre class="literal-block">
class Example4( Default_App ):
    dealer_rule= Hit17()
    split_rule= NoReSplitAces()
    table= Table( decks=6, limit=50, dealer=dealer_rule,
        split=split_rule, payout=(3,2) )
    player_rule= SomeStrategy()
    betting_rule= Flat()
    player= Player( play=player_rule, betting=betting_rule, rounds=100, stake=50 )
    outputfile= &quot;p2_c13_simulation4.dat&quot;
    samples= 100

if __name__ == &quot;__main__&quot;:
    simulate_c(Example4())
    check(&quot;p2_c13_simulation4.dat&quot;)
</pre>
</div>
<div class="section" id="top-level-v3">
<h2><a class="toc-backref" href="#id6">3.3&nbsp;&nbsp;&nbsp;Top-level -- v3</a></h2>
<p>SimpleNamespace version a</p>
<pre class="literal-block">
import types
config5a= types.SimpleNamespace(
        dealer_rule= Hit17(),
        split_rule= NoReSplitAces(),
        player_rule= SomeStrategy(),
        betting_rule= Flat(),
        outputfile= &quot;p2_c13_simulation5a.dat&quot;,
        samples= 100,
        )

config5a.table= Table( decks=6, limit=50, dealer=config5a.dealer_rule,
        split=config5a.split_rule, payout=(3,2) )
config5a.player= Player( play=config5a.player_rule, betting=config5a.betting_rule,
        rounds=100, stake=50 )

if __name__ == &quot;__main__&quot;:
    simulate_c(config5a)
    check(&quot;p2_c13_simulation5a.dat&quot;)
</pre>
<p>SimpleNamespace version b</p>
<pre class="literal-block">
import types
config5b= types.SimpleNamespace()
config5b.dealer_rule= Hit17()
config5b.split_rule= NoReSplitAces()
config5b.table= Table( decks=6, limit=50, dealer=config5b.dealer_rule,
        split=config5b.split_rule, payout=(3,2) )
config5b.player_rule= SomeStrategy()
config5b.betting_rule= Flat()
config5b.player= Player( play=config5b.player_rule, betting=config5b.betting_rule,
        rounds=100, stake=50 )
config5b.outputfile= &quot;p2_c13_simulation5b.dat&quot;
config5b.samples= 100

if __name__ == &quot;__main__&quot;:
    simulate_c(config5b)
    check(&quot;p2_c13_simulation5b.dat&quot;)
</pre>
</div>
<div class="section" id="execfile-import">
<h2><a class="toc-backref" href="#id7">3.4&nbsp;&nbsp;&nbsp;Execfile Import</a></h2>
<p>Handy class to allow us attribute-like access</p>
<pre class="literal-block">
class AttrDict( dict ):
    def __getattr__( self, name ):
        return self.get(name,None)
    def __setattr__( self, name, value ):
        self[name]= value
    def __dir__( self ):
        return list(self.keys())

import io
py_file= io.StringIO( &quot;&quot;&quot;
# SomeStrategy setup

# Table
dealer_rule= Hit17()
split_rule= NoReSplitAces()
table= Table( decks=6, limit=50, dealer=dealer_rule,
        split=split_rule, payout=(3,2) )

# Player
player_rule= SomeStrategy()
betting_rule= Flat()
player= Player( play=player_rule, betting=betting_rule,
        rounds=100, stake=50 )

# Simulation
outputfile= &quot;p2_c13_simulation6.dat&quot;
samples= 100
&quot;&quot;&quot; )

if __name__ == &quot;__main__&quot;:
    config= AttrDict()
    code= compile(py_file.read(),'stringio','exec')
    exec( code, globals(), config  )

    from pprint import pprint
    pprint( config )
    print( config.table )

    simulate( config.table, config.player, config.outputfile, config.samples)
    check( config.outputfile )
</pre>
</div>
</div>
<div class="section" id="chainmap-and-import">
<h1><a class="toc-backref" href="#id8">4&nbsp;&nbsp;&nbsp;ChainMap and Import</a></h1>
<p>Essential Example</p>
<pre class="literal-block">
from collections import ChainMap
import os
config_name= &quot;config.py&quot;
config_locations = (
    os.path.expanduser(&quot;~thisapp/&quot;), # or thisapp.__file__,
    &quot;/etc&quot;,
    os.path.expanduser(&quot;~/&quot;),
    os.path.curdir,
)
candidates = ( os.path.join(dir,config_name)
    for dir in config_locations )
config_names = ( name for name in candidates if os.path.exists(name) )
config = ChainMap()
for name in config_names:
    config= config.new_child()
    exec(name, globals(), config)
</pre>
<p>Demo with Mock files</p>
<pre class="literal-block">
import io
py_file= io.StringIO( &quot;&quot;&quot;
# Default casino rules
# Table
dealer_rule= Hit17()
split_rule= NoReSplitAces()
table= Table( decks=6, limit=50, dealer=dealer_rule,
        split=split_rule, payout=(3,2) )

# Player
player_rule= SomeStrategy()
betting_rule= Flat()
player= Player( play=player_rule, betting=betting_rule,
        rounds=100, stake=50 )

# Simulation
outputfile= &quot;p2_c13_simulation7.dat&quot;
samples= 100
&quot;&quot;&quot; )

py2_file= io.StringIO( &quot;&quot;&quot;
# Player
player_rule= AnotherStrategy()
player= Player( play=player_rule, betting=betting_rule,
        rounds=100, stake=50 )

# Simulation
outputfile= &quot;p2_c13_simulation7a.dat&quot;
&quot;&quot;&quot; )

class AttrChainMap( ChainMap ):
    def __getattr__( self, name ):
        if name == &quot;maps&quot;:
            return self.__dict__['maps']
        return super().get(name,None)
    def __setattr__( self, name, value ):
        if name == &quot;maps&quot;:
            self.__dict__['maps']= value
            return
        self[name]= value

if __name__ == &quot;__main__&quot;:

    config = AttrChainMap()
    for file in py_file, py2_file:
        config= config.new_child()
        exec(file.read(),globals(),config)

    pprint( config )
    print( config.table )
    print( config['table'] )

    simulate( config.table, config.player, config.outputfile, config.samples)
    check( config.outputfile )
</pre>
</div>
<div class="section" id="json-or-yaml-files">
<h1><a class="toc-backref" href="#id9">5&nbsp;&nbsp;&nbsp;JSON or YAML files</a></h1>
<p>JSON using dictionary-of-dictionaries nested structures.
This is inconvenient to handle multiple configuration files.</p>
<pre class="literal-block">
import io
json_file= io.StringIO( &quot;&quot;&quot;
{
    &quot;table&quot;:{
        &quot;dealer&quot;:&quot;Hit17&quot;,
        &quot;split&quot;:&quot;NoResplitAces&quot;,
        &quot;decks&quot;:6,
        &quot;limit&quot;:50,
        &quot;payout&quot;:[3,2]
    },
    &quot;player&quot;:{
        &quot;play&quot;:&quot;SomeStrategy&quot;,
        &quot;betting&quot;:&quot;Flat&quot;,
        &quot;rounds&quot;:100,
        &quot;stake&quot;:50
    },
    &quot;simulator&quot;:{
        &quot;samples&quot;:100,
        &quot;outputfile&quot;:&quot;p2_c13_simulation8.dat&quot;
    }
}
&quot;&quot;&quot;)

def main_nested_dict( config ):
    dealer_nm= config.get('table',{}).get('dealer', 'Hit17')
    dealer_rule= {'Hit17':Hit17(),
        'Stand17':Stand17()}.get(dealer_nm, Hit17())
    split_nm= config.get('table',{}).get('split', 'ReSplit')
    split_rule= {'ReSplit':ReSplit(),
        'NoReSplit':NoReSplit(),
        'NoReSplitAces':NoReSplitAces()}.get(split_nm, ReSplit())
    decks= config.get('table',{}).get('decks', 6)
    limit= config.get('table',{}).get('limit', 100)
    payout= config.get('table',{}).get('payout', (3,2))
    table= Table( decks=decks, limit=limit, dealer=dealer_rule,
        split=split_rule, payout=payout )

    player_nm= config.get('player',{}).get('play', 'SomeStrategy')
    player_rule= {'SomeStrategy':SomeStrategy(),
        'AnotherStrategy':AnotherStrategy()}.get(player_nm,SomeStrategy())
    bet_nm= config.get('player',{}).get('betting', 'Flat')
    betting_rule= {'Flat':Flat(),
        'Martingale':Martingale(),
        'OneThreeTwoSix':OneThreeTwoSix()}.get(bet_nm,Flat())
    rounds= config.get('player',{}).get('rounds', 100)
    stake= config.get('player',{}).get('stake', 50)
    player= Player( play=player_rule, betting=betting_rule,
        rounds=rounds, stake=stake )

    outputfile= config.get('simulator',{}).get('outputfile', 'blackjack.csv')
    samples= config.get('simulator',{}).get('samples', 100)
    simulator= Simulate( table, player, samples )
    with open(outputfile,&quot;w&quot;,newline=&quot;&quot;) as results:
        wtr= csv.writer( results )
        for gamestats in simulator:
            wtr.writerow( gamestats )

if __name__ == &quot;__main__&quot;:
    import json
    config= json.load( json_file )
    main_nested_dict( config )
    check( config['simulator']['outputfile'] )
</pre>
<p>Flat Version, allows multiple configuration files.</p>
<pre class="literal-block">
json2_file= io.StringIO(&quot;&quot;&quot;
{
&quot;player.betting&quot;: &quot;Flat&quot;,
&quot;player.play&quot;: &quot;SomeStrategy&quot;,
&quot;player.rounds&quot;: 100,
&quot;player.stake&quot;: 50,
&quot;table.dealer&quot;: &quot;Hit17&quot;,
&quot;table.decks&quot;: 6,
&quot;table.limit&quot;: 50,
&quot;table.payout&quot;: [3, 2],
&quot;table.split&quot;: &quot;NoResplitAces&quot;,
&quot;simulator.outputfile&quot;: &quot;p2_c13_simulation8.dat&quot;,
&quot;simulator.samples&quot;: 100
}
&quot;&quot;&quot; )

json3_file= io.StringIO(&quot;&quot;&quot;
{
&quot;player.betting&quot;: &quot;Flat&quot;,
&quot;simulator.outputfile&quot;: &quot;p2_c13_simulation8a.dat&quot;
}
&quot;&quot;&quot; )
</pre>
<p>Using the config to build objects</p>
<pre class="literal-block">
def main_cm( config ):
    dealer_nm= config.get('table.dealer', 'Hit17')
    dealer_rule= {'Hit17':Hit17(),
        'Stand17':Stand17()}.get(dealer_nm, Hit17())
    split_nm= config.get('table.split', 'ReSplit')
    split_rule= {'ReSplit':ReSplit(),
        'NoReSplit':NoReSplit(),
        'NoReSplitAces':NoReSplitAces()}.get(split_nm, ReSplit())
    decks= int(config.get('table.decks', 6))
    limit= int(config.get('table.limit', 100))
    payout= config.get('table.payout', (3,2))
    table= Table( decks=decks, limit=limit, dealer=dealer_rule,
        split=split_rule, payout=payout )

    player_nm= config.get('player.play', 'SomeStrategy')
    player_rule= {'SomeStrategy':SomeStrategy(),
        'AnotherStrategy':AnotherStrategy()}.get(player_nm,SomeStrategy())
    bet_nm= config.get('player.betting', 'Flat')
    betting_rule= {'Flat':Flat(),
        'Martingale':Martingale(),
        'OneThreeTwoSix':OneThreeTwoSix()}.get(bet_nm,Flat())
    rounds= int(config.get('player.rounds', 100))
    stake= int(config.get('player.stake', 50))
    player= Player( play=player_rule, betting=betting_rule,
        rounds=rounds, stake=stake )

    outputfile= config.get('simulator.outputfile', 'blackjack.csv')
    samples= int(config.get('simulator.samples', 100))
    simulator= Simulate( table, player, samples )
    with open(outputfile,&quot;w&quot;,newline=&quot;&quot;) as results:
        wtr= csv.writer( results )
        for gamestats in simulator:
            wtr.writerow( gamestats )
</pre>
<p>Sample Main Script to parse and start the application.</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    config_files= json2_file, json3_file,
    config = ChainMap( *[json.load(file) for file in reversed(config_files)] )
    print( config )

    main_cm(config)

    check( config.get('simulator.outputfile') )
</pre>
<div class="section" id="yaml">
<h2><a class="toc-backref" href="#id10">5.1&nbsp;&nbsp;&nbsp;YAML</a></h2>
<p>Simple YAML</p>
<pre class="literal-block">
yaml1_file= io.StringIO(&quot;&quot;&quot;
player:
  betting: Flat
  play: SomeStrategy
  rounds: 100
  stake: 50
table:
  dealer: Hit17
  decks: 6
  limit: 50
  payout: [3, 2]
  split: NoResplitAces
simulator: {outputfile: p2_c13_simulation.dat, samples: 100}
&quot;&quot;&quot;)

import yaml
config= yaml.load( yaml1_file )
if __name__ == &quot;__main__&quot;:
    from pprint import pprint
    pprint( config )


yaml1_file= io.StringIO(&quot;&quot;&quot;
# Complete Simulation Settings
table: !!python/object:__main__.Table
  dealer: !!python/object:__main__.Hit17 {}
  decks: 6
  limit: 50
  payout: !!python/tuple [3, 2]
  split: !!python/object:__main__.NoReSplitAces {}
player: !!python/object:__main__.Player
  betting:  !!python/object:__main__.Flat {}
  init_stake: 50
  max_rounds: 100
  play: !!python/object:__main__.SomeStrategy {}
  rounds: 0
  stake: 63.0
samples: 100
outputfile: p2_c13_simulation9.dat
&quot;&quot;&quot;)

if __name__ == &quot;__main__&quot;:
    import yaml
    config= yaml.load( yaml1_file )
    print( config )

    simulate( config['table'], config['player'], config['outputfile'], config['samples'] )
    check( config['outputfile'] )
</pre>
</div>
</div>
<div class="section" id="property-files">
<h1><a class="toc-backref" href="#id11">6&nbsp;&nbsp;&nbsp;Property files</a></h1>
<ul class="simple">
<li>Lines have keys and values.</li>
<li>Key ends with the first unescaped '=', ':', or white space character.</li>
<li>Value is optional and defaults to &quot;&quot;.</li>
<li>Number sign (#) or the exclamation mark (!) as
the first non blank character in a line is a comment.</li>
<li>The backwards slash is used to escape a character.</li>
<li>Since  #, !, =, and : have meaning,
when involved in a piece of key or element, use a preceding backslash</li>
<li>Key with spaces is tolerated using ''.</li>
<li>Key or value with newline is tolerated using '\n'.</li>
<li>Unicode escapes may be used:  uxxxx is the format.</li>
<li>Everything is text, explicit conversions required</li>
</ul>
<p>Example 1
From <a class="reference external" href="http://en.wikipedia.org/wiki/.properties">http://en.wikipedia.org/wiki/.properties</a></p>
<pre class="literal-block">
prop1=&quot;&quot;&quot;
# You are reading the &quot;.properties&quot; entry.
! The exclamation mark can also mark text as comments.
# The key and element characters #, !, =, and : are written with a preceding backslash to ensure that they are properly loaded.
website = http\://en.wikipedia.org/
language = English
# The backslash below tells the application to continue reading
# the value onto the next line.
message = Welcome to \\
          Wikipedia\!
# Add spaces to the key
key\ with\ spaces = This is the value that could be looked up with the key &quot;key with spaces&quot;.
# Unicode
tab : \\u0009
&quot;&quot;&quot;
</pre>
<p>Example 2
From <a class="reference external" href="http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html">http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html</a></p>
<pre class="literal-block">
prop2=&quot;&quot;&quot;
\:\=
Truth = Beauty
 Truth:Beauty
Truth                    :Beauty

fruits                          apple, banana, pear, \\
                                cantaloupe, watermelon, \\
                                kiwi, mango

cheeses
&quot;&quot;&quot;
</pre>
<p>Property File Parsing Class</p>
<pre class="literal-block">
import re
class PropertyParser:
    def read_string( self, data ):
        return self._parse(data)
    def read_file( self, file ):
        data= file.read()
        return self.read_string( data )
    def read( self, filename ):
        with open(filename) as file:
            return self.read_file( file )

    key_element_pat= re.compile(r&quot;(.*?)\s*(?&lt;!\\)[:=\s]\s*(.*)&quot;)
    def _parse( self, data ):
        logical_lines = (line.strip()
            for line in re.sub(r&quot;\\\n\s*&quot;, &quot;&quot;, data).splitlines())
        non_empty= (line for line in logical_lines
            if len(line) != 0)
        non_comment= (line for line in non_empty
            if not( line.startswith(&quot;#&quot;) or line.startswith(&quot;!&quot;) ) )
        for line in non_comment:
            ke_match= self.key_element_pat.match(line)
            if ke_match:
                key, element = ke_match.group(1), ke_match.group(2)
            else:
                key, element = line, &quot;&quot;
            key= self._escape(key)
            element= self._escape(element)
            yield key, element

    def load( self, file_or_name ):
        if isinstance(file_or_name,io.TextIOBase):
            self.loads(file_or_name.read())
        else:
            with open(filename) as file:
                self.loads(file.read())
    def loads( self, string ):
        return self._parse(data)

    def _escape( self, data ):
        d1= re.sub( r&quot;\\([:#!=\s])&quot;, lambda x:x.group(1), data )
        d2= re.sub( r&quot;\\u([0-9A-Fa-f]+)&quot;, lambda x:chr(int(x.group(1),16)), d1 )
        return d2

    def _escape2( self, data ):
        d2= re.sub( r&quot;\\([:#!=\s])|\\u([0-9A-Fa-f]+)&quot;,
            lambda x:x.group(1) if x.group(1) else chr(int(x.group(2),16)), data )
        return d2
</pre>
<p>A Formal Unit Test. We'll use the examples from the Wikipedia page
and from the Java page to be sure we're getting sensible output.</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    import unittest
</pre>
<p>TestCase class definition</p>
<pre class="literal-block">
class TestPropertyParser( unittest.TestCase ):
</pre>
<p>A setUp method to construct an instance of the parser
:</p>
<pre class="literal-block">
def setUp( self ):
    self.parser= PropertyParser()
</pre>
<p>A test for the prop1 example. We can create a dict since each key
is unique.</p>
<pre class="literal-block">
def test_should_parse_prop1( self ):
    actual= dict(self.parser.read_string( prop1 ))
    expected= {
        'key with spaces': 'This is the value that could be looked up with the key &quot;key with spaces&quot;.',
        'language': 'English',
        'message': 'Welcome to Wikipedia!',
        'tab': '\t',
        'website': 'http://en.wikipedia.org/'}
    self.assertDictEqual( expected, actual )
</pre>
<p>A test for the prop2 example. We create a list since each key
is not unique. The list is merely for testing, no practical app
can depend on duplicate keys.</p>
<pre class="literal-block">
def test_should_parse_prop2( self ):
    actual= list(self.parser.read_string( prop2 ))
    expected= [
        (':=', ''),
        ('Truth', 'Beauty'),
        ('Truth', 'Beauty'),
        ('Truth', 'Beauty'),
        ('fruits', 'apple, banana, pear, cantaloupe, watermelon, kiwi, mango'),
        ('cheeses', '')]
    self.assertListEqual( expected, actual )
</pre>
<p>The test suite</p>
<pre class="literal-block">
def suite():
    s= unittest.TestSuite()
    s.addTests( unittest.defaultTestLoader.loadTestsFromTestCase(TestPropertyParser) )
    return s
</pre>
<p>Run the suite.</p>
<pre class="literal-block">
t= unittest.TextTestRunner()
t.run( suite() )
</pre>
<p>Main Program to use property file input</p>
<pre class="literal-block">
import ast
def main_cm_str( config ):
    dealer_nm= config.get('table.dealer', 'Hit17')
    dealer_rule= {'Hit17':Hit17(),
        'Stand17':Stand17()}.get(dealer_nm, Hit17())
    split_nm= config.get('table.split', 'ReSplit')
    split_rule= {'ReSplit':ReSplit(),
        'NoReSplit':NoReSplit(),
        'NoReSplitAces':NoReSplitAces()}.get(split_nm, ReSplit())
    decks= int(config.get('table.decks', 6))
    limit= int(config.get('table.limit', 100))
    payout= ast.literal_eval(config.get('table.payout', '(3,2)'))
    table= Table( decks=decks, limit=limit, dealer=dealer_rule,
        split=split_rule, payout=payout )

    player_nm= config.get('player.play', 'SomeStrategy')
    player_rule= {'SomeStrategy':SomeStrategy(),
        'AnotherStrategy':AnotherStrategy()}.get(player_nm,SomeStrategy())
    bet_nm= config.get('player.betting', 'Flat')
    betting_rule= {'Flat':Flat(),
        'Martingale':Martingale(),
        'OneThreeTwoSix':OneThreeTwoSix()}.get(bet_nm,Flat())
    rounds= int(config.get('player.rounds', 100))
    stake= int(config.get('player.stake', 50))
    player= Player( play=player_rule, betting=betting_rule,
        rounds=rounds, stake=stake )

    outputfile= config.get('simulator.outputfile', 'blackjack.csv')
    samples= int(config.get('simulator.samples', 100))
    simulator= Simulate( table, player, samples )
    with open(outputfile,&quot;w&quot;,newline=&quot;&quot;) as results:
        wtr= csv.writer( results )
        for gamestats in simulator:
            wtr.writerow( gamestats )
</pre>
<p>Example property file.</p>
<pre class="literal-block">
prop_file= io.StringIO(&quot;&quot;&quot;
# Example Simulation Setup

player.betting: Flat
player.play: SomeStrategy
player.rounds: 100
player.stake: 50

table.dealer: Hit17
table.decks: 6
table.limit: 50
table.payout: (3,2)
table.split: NoResplitAces

simulator.outputfile = p2_c13_simulation10.dat
simulator.samples = 100
&quot;&quot;&quot;)

if __name__ == &quot;__main__&quot;:
    pp= PropertyParser()

    candidate_list= [ prop_file ]
    config= ChainMap(
        *[dict( pp.read_file(file) )
        for file in reversed(candidate_list)] )

    main_cm_str( config )
    check( config['simulator.outputfile'] )
</pre>
</div>
<div class="section" id="xml-files">
<h1><a class="toc-backref" href="#id12">7&nbsp;&nbsp;&nbsp;XML files</a></h1>
<div class="section" id="plist">
<h2><a class="toc-backref" href="#id13">7.1&nbsp;&nbsp;&nbsp;Plist</a></h2>
<p>Sample PLIST Document. As bytes.</p>
<pre class="literal-block">
import io
plist_file= io.BytesIO( b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;
&lt;plist version=&quot;1.0&quot;&gt;
&lt;dict&gt;
    &lt;key&gt;player&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;betting&lt;/key&gt;
        &lt;string&gt;Flat&lt;/string&gt;
        &lt;key&gt;play&lt;/key&gt;
        &lt;string&gt;SomeStrategy&lt;/string&gt;
        &lt;key&gt;rounds&lt;/key&gt;
        &lt;integer&gt;100&lt;/integer&gt;
        &lt;key&gt;stake&lt;/key&gt;
        &lt;integer&gt;50&lt;/integer&gt;
    &lt;/dict&gt;
    &lt;key&gt;simulator&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;outputfile&lt;/key&gt;
        &lt;string&gt;p2_c13_simulation8.dat&lt;/string&gt;
        &lt;key&gt;samples&lt;/key&gt;
        &lt;integer&gt;100&lt;/integer&gt;
    &lt;/dict&gt;
    &lt;key&gt;table&lt;/key&gt;
    &lt;dict&gt;
        &lt;key&gt;dealer&lt;/key&gt;
        &lt;string&gt;Hit17&lt;/string&gt;
        &lt;key&gt;decks&lt;/key&gt;
        &lt;integer&gt;6&lt;/integer&gt;
        &lt;key&gt;limit&lt;/key&gt;
        &lt;integer&gt;50&lt;/integer&gt;
        &lt;key&gt;payout&lt;/key&gt;
        &lt;array&gt;
            &lt;integer&gt;3&lt;/integer&gt;
            &lt;integer&gt;2&lt;/integer&gt;
        &lt;/array&gt;
        &lt;key&gt;split&lt;/key&gt;
        &lt;string&gt;NoResplitAces&lt;/string&gt;
    &lt;/dict&gt;
&lt;/dict&gt;
&lt;/plist&gt;
&quot;&quot;&quot;)
</pre>
</div>
<div class="section" id="non-plist">
<h2><a class="toc-backref" href="#id14">7.2&nbsp;&nbsp;&nbsp;Non-Plist</a></h2>
<p>A completely customized XML document</p>
<pre class="literal-block">
import io
xml_file= io.BytesIO( b&quot;&quot;&quot;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;simulation&gt;
    &lt;table&gt;
        &lt;dealer&gt;Hit17&lt;/dealer&gt;
        &lt;split&gt;NoResplitAces&lt;/split&gt;
        &lt;decks&gt;6&lt;/decks&gt;
        &lt;limit&gt;50&lt;/limit&gt;
        &lt;payout&gt;(3,2)&lt;/payout&gt;
    &lt;/table&gt;
    &lt;player&gt;
        &lt;betting&gt;Flat&lt;/betting&gt;
        &lt;play&gt;SomeStrategy&lt;/play&gt;
        &lt;rounds&gt;100&lt;/rounds&gt;
        &lt;stake&gt;50&lt;/stake&gt;
    &lt;/player&gt;
    &lt;simulator&gt;
        &lt;outputfile&gt;p2_c13_simulation11.dat&lt;/outputfile&gt;
        &lt;samples&gt;100&lt;/samples&gt;
    &lt;/simulator&gt;
&lt;/simulation&gt;
&quot;&quot;&quot;)

import xml.etree.ElementTree as XML
class Configuration:
    def read_file( self, file ):
        self.config= XML.parse( file )
    def read( self, filename ):
        self.config= XML.parse( filename )
    def read_string( self, text ):
        self.config= XML.fromstring( text )
    def get( self, qual_name, default ):
        section, _, item = qual_name.partition(&quot;.&quot;)
        query= &quot;./{0}/{1}&quot;.format( section, item )
        node= self.config.find(query)
        if node is None: return default
        return node.text
    def __getitem__( self, section ):
        query= &quot;./{0}&quot;.format(section)
        parent= self.config.find(query)
        return dict( (item.tag, item.text) for item in parent )

if __name__ == &quot;__main__&quot;:

    config= Configuration()
    config.read_file( xml_file )
    main_cm_str( config )
    check( config['simulator']['outputfile'] )
</pre>
</div>
</div>
</div>
</body>
</html>
