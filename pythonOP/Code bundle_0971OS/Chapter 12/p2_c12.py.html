<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/" />
<title></title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<style type="text/css">

/* example stylesheet for Docutils */

/* :Author:    Günter Milde */
/* :Copyright: © 2012 G. Milde */
/* :License:   This stylesheet is placed in the public domain. */

/* Syntax highlight rules for HTML documents generated with Docutils */
/* using the ``--syntax-highlight=long`` option (new in v. 0.9). */

/* This stylesheet implements Pygment's "default" style with less rules than */
/* pygments-default using class hierarchies.                                 */
/* Use it as example for "handcrafted" styles with only few rules.      */

.code                              { background: #f8f8f8; }
.code .comment                     { color: #008800; font-style: italic }
.code .error                       { border: 1px solid #FF0000 }
.code .generic.deleted             { color: #A00000 }
.code .generic.emph                { font-style: italic }
.code .generic.error               { color: #FF0000 }
.code .generic.heading             { color: #000080; font-weight: bold }
.code .generic.inserted            { color: #00A000 }
.code .generic.output              { color: #808080 }
.code .generic.prompt              { color: #000080; font-weight: bold }
.code .generic.strong              { font-weight: bold }
.code .generic.subheading          { color: #800080; font-weight: bold }
.code .generic.traceback           { color: #0040D0 }
.code .keyword                     { color: #AA22FF; font-weight: bold }
.code .keyword.pseudo              { font-weight: normal }
.code .literal.number              { color: #666666 }
.code .literal.string              { color: #BB4444 }
.code .literal.string.doc          { color: #BB4444; font-style: italic }
.code .literal.string.escape       { color: #BB6622; font-weight: bold }
.code .literal.string.interpol     { color: #BB6688; font-weight: bold }
.code .literal.string.other        { color: #008000 }
.code .literal.string.regex        { color: #BB6688 }
.code .literal.string.symbol       { color: #B8860B }
.code .name.attribute              { color: #BB4444 }
.code .name.builtin                { color: #AA22FF }
.code .name.class                  { color: #0000FF }
.code .name.constant               { color: #880000 }
.code .name.decorator              { color: #AA22FF }
.code .name.entity                 { color: #999999; font-weight: bold }
.code .name.exception              { color: #D2413A; font-weight: bold }
.code .name.function               { color: #00A000 }
.code .name.label                  { color: #A0A000 }
.code .name.namespace              { color: #0000FF; font-weight: bold }
.code .name.tag                    { color: #008000; font-weight: bold }
.code .name.variable               { color: #B8860B }
.code .operator                    { color: #666666 }
.code .operator.word               { color: #AA22FF; font-weight: bold }

</style>
<style type="text/css">

/* Page layout tweaks */
div.document { width: 6in; }

</style>
</head>
<body>
<div class="document">


<!-- #!/usr/bin/env python3 -->
<div class="section" id="chapter-12-transmission">
<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;Chapter 12 -- Transmission</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#chapter-12-transmission" id="id1">1&nbsp;&nbsp;&nbsp;Chapter 12 -- Transmission</a><ul class="auto-toc">
<li><a class="reference internal" href="#rest-basics" id="id2">1.1&nbsp;&nbsp;&nbsp;REST basics</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rest-client" id="id3">2&nbsp;&nbsp;&nbsp;REST Client</a></li>
<li><a class="reference internal" href="#roulette-demo" id="id4">3&nbsp;&nbsp;&nbsp;Roulette Demo</a><ul class="auto-toc">
<li><a class="reference internal" href="#rest-revised-callable-wsgi-applications" id="id5">3.1&nbsp;&nbsp;&nbsp;REST Revised: Callable WSGI Applications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#roulette2-demo" id="id6">4&nbsp;&nbsp;&nbsp;Roulette2 Demo</a><ul class="auto-toc">
<li><a class="reference internal" href="#rest-with-sessions-and-state" id="id7">4.1&nbsp;&nbsp;&nbsp;REST with sessions and state</a></li>
<li><a class="reference internal" href="#rest-with-authentication" id="id8">4.2&nbsp;&nbsp;&nbsp;REST with authentication</a></li>
<li><a class="reference internal" href="#multiprocessing-example" id="id9">4.3&nbsp;&nbsp;&nbsp;Multiprocessing Example</a></li>
</ul>
</li>
<li><a class="reference internal" href="#create-and-run-the-simulation" id="id10">5&nbsp;&nbsp;&nbsp;Create and run the simulation</a></li>
</ul>
</div>
<div class="section" id="rest-basics">
<h2><a class="toc-backref" href="#id2">1.1&nbsp;&nbsp;&nbsp;REST basics</a></h2>
<p>Stateless. Roulette.  Base class definitions.</p>
<pre class="literal-block">
import random

class Wheel:
    &quot;&quot;&quot;Abstract, zero bins omitted.&quot;&quot;&quot;
    def __init__( self ):
        self.rng= random.Random()
        self.bins= [
            {str(n): (35,1),
            self.redblack(n): (1,1),
            self.hilo(n): (1,1),
            self.evenodd(n): (1,1),
            } for n in range(1,37)
        ]
    &#64;staticmethod
    def redblack(n):
        return &quot;Red&quot; if n in (1, 3, 5, 7, 9,  12, 14, 16, 18,
            19, 21, 23, 25, 27,  30, 32, 34, 36) else &quot;Black&quot;
    &#64;staticmethod
    def hilo(n):
        return &quot;Hi&quot; if n &gt;= 19 else &quot;Lo&quot;
    &#64;staticmethod
    def evenodd(n):
        return &quot;Even&quot; if n % 2 == 0 else &quot;Odd&quot;
    def spin( self ):
        return self.rng.choice( self.bins )

class Zero:
    def __init__( self ):
        super().__init__()
        self.bins += [ {'0': (35,1)} ]

class DoubleZero:
    def __init__( self ):
        super().__init__()
        self.bins += [ {'00': (35,1)} ]

class American( Zero, DoubleZero, Wheel ):
    pass

class European( Zero, Wheel ):
    pass
</pre>
<p>Some global objects used by a WSGI application function</p>
<pre class="literal-block">
american = American()
european = European()
if __name__ == &quot;__main__&quot;:
    print( &quot;SPIN&quot;, american.spin() )
    #print( [b.keys() for b in american.bins]  )

import sys
import wsgiref.util
import json
def wheel(environ, start_response):
    request= wsgiref.util.shift_path_info(environ) # 1. Parse.
    print( &quot;wheel&quot;, repr(request), file=sys.stderr ) # 2. Logging.
    if request.lower().startswith('eu'): # 3. Evaluate.
        winner= european.spin()
    else:
        winner= american.spin()
    status = '200 OK' # 4. Respond.
    headers = [('Content-type', 'application/json; charset=utf-8')]
    start_response(status, headers)
    return [ json.dumps(winner).encode('UTF-8') ]
</pre>
<p>A function we can call to start a server
which handles a finite number of requests.
Handy for testing.</p>
<pre class="literal-block">
def roulette_server(count=1):
    from wsgiref.simple_server import make_server
    httpd = make_server('', 8080, wheel)
    if count is None:
        httpd.serve_forever()
    else:
        for c in range(count):
            httpd.handle_request()
</pre>
</div>
</div>
<div class="section" id="rest-client">
<h1><a class="toc-backref" href="#id3">2&nbsp;&nbsp;&nbsp;REST Client</a></h1>
<p>A REST client that simply loads a JSON document.</p>
<pre class="literal-block">
import http.client
import json
def json_get(path=&quot;/&quot;):
    rest= http.client.HTTPConnection('localhost', 8080, timeout=5)
    rest.request(&quot;GET&quot;, path)
    response= rest.getresponse()
    print( response.status, response.reason )
    print( response.getheaders() )
    raw= response.read().decode(&quot;utf-8&quot;)
    if response.status == 200:
        document= json.loads(raw)
        print( document )
    else:
        print( raw )
</pre>
</div>
<div class="section" id="roulette-demo">
<h1><a class="toc-backref" href="#id4">3&nbsp;&nbsp;&nbsp;Roulette Demo</a></h1>
<p>When run as the main script, start a server and interact with it.</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:

    import concurrent.futures
    import time
    with concurrent.futures.ProcessPoolExecutor() as executor:
        executor.submit( roulette_server, 4 )
        time.sleep(2) # Wait for the server to start
        json_get()
        json_get()
        json_get(&quot;/european/&quot;)
        json_get(&quot;/european/&quot;)
</pre>
<div class="section" id="rest-revised-callable-wsgi-applications">
<h2><a class="toc-backref" href="#id5">3.1&nbsp;&nbsp;&nbsp;REST Revised: Callable WSGI Applications</a></h2>
<p>A WSGI Callable object.</p>
<pre class="literal-block">
from collections.abc import Callable

class Wheel2( Wheel, Callable ):
    def __call__(self, environ, start_response):
        winner= self.spin()
        status = '200 OK'
        headers = [('Content-type', 'application/json; charset=utf-8')]
        start_response(status, headers)
        return [ json.dumps(winner).encode('UTF-8') ]

class American2( Zero, DoubleZero, Wheel2 ):
    pass

class European2( Zero, Wheel2 ):
    pass
</pre>
<p>A WSGI wrapper application.</p>
<pre class="literal-block">
import sys
class Wheel3( Callable ):
    def __init__( self ):
        self.am = American2()
        self.eu = European2()
    def __call__(self, environ, start_response):
        request= wsgiref.util.shift_path_info(environ) # 1. Parse.
        print( &quot;Wheel3&quot;, request, file=sys.stderr ) # 2. Logging.
        if request.lower().startswith('eu'): # 3. Evaluate.
            response= self.eu(environ,start_response)
        else:
            response= self.am(environ,start_response)
        return response # 4. Respond.
</pre>
<p>Revised Server</p>
<pre class="literal-block">
def roulette_server_3(count=1):
    from wsgiref.simple_server import make_server
    httpd = make_server('', 8080, Wheel3())
    if count is None:
        httpd.serve_forever()
    else:
        for c in range(count):
            httpd.handle_request()
</pre>
</div>
</div>
<div class="section" id="roulette2-demo">
<h1><a class="toc-backref" href="#id6">4&nbsp;&nbsp;&nbsp;Roulette2 Demo</a></h1>
<p>When run as the main script, start a server and interact with it.</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:

    import concurrent.futures
    import time
    with concurrent.futures.ProcessPoolExecutor() as executor:
        executor.submit( roulette_server_3, 2 )
        time.sleep(2) # Wait for the server to start
        json_get(&quot;/am/&quot;)
        json_get(&quot;/eu/&quot;)
</pre>
<div class="section" id="rest-with-sessions-and-state">
<h2><a class="toc-backref" href="#id7">4.1&nbsp;&nbsp;&nbsp;REST with sessions and state</a></h2>
<p>Player and Bet for Roulette.</p>
<p>CRUD design issues.
Player:
- GET to see stake and rounds played.
Bet:
- POST to create a series of bets or decline to bet.
- GET to see bets.
Wheel:
- GET to get spin and payout.</p>
<p>Stateful object</p>
<pre class="literal-block">
from collections import defaultdict
class Table:
    def __init__( self, stake=100 ):
        self.bets= defaultdict(int)
        self.stake= stake
    def place_bet( self, name, amount ):
        self.bets[name] += amount
    def clear_bets( self, name ):
        self.bets= defaultdict(int)
    def resolve( self, spin ):
        &quot;&quot;&quot;spin is a dict with bet:(x:y).&quot;&quot;&quot;
        details= []
        while self.bets:
            bet, amount= self.bets.popitem()
            if bet in spin:
                x, y = spin[bet]
                self.stake += amount*x/y
                details.append( (bet, amount, 'win') )
            else:
                self.stake -= amount
                details.append( (bet, amount, 'lose') )
        return details
</pre>
<p>WSGI Applications</p>
<pre class="literal-block">
class WSGI( Callable ):
    def __call__( self, environ, start_response ):
        raise NotImplementedError

class RESTException( Exception ):
    pass

class Roulette( WSGI ):
    def __init__( self, wheel ):
        self.table= Table(100)
        self.rounds= 0
        self.wheel= wheel
    def __call__( self, environ, start_response ):
        #print( environ, file=sys.stderr )
        app= wsgiref.util.shift_path_info(environ)
        try:
            if app.lower() == &quot;player&quot;:
                return self.player_app( environ, start_response )
            elif app.lower() == &quot;bet&quot;:
                return self.bet_app( environ, start_response )
            elif app.lower() == &quot;wheel&quot;:
                return self.wheel_app( environ, start_response )
            else:
                raise RESTException(&quot;404 NOT_FOUND&quot;,
                    &quot;Unknown app in {SCRIPT_NAME}/{PATH_INFO}&quot;.format_map(environ))
        except RESTException as e:
            status= e.args[0]
            headers = [('Content-type', 'text/plain; charset=utf-8')]
            start_response( status, headers, sys.exc_info() )
            return [ repr(e.args).encode(&quot;UTF-8&quot;) ]

    def player_app( self, environ, start_response ):
        if environ['REQUEST_METHOD'] == 'GET':
            details= dict( stake= self.table.stake, rounds= self.rounds )
            status = '200 OK'
            headers = [('Content-type', 'application/json; charset=utf-8')]
            start_response(status, headers)
            return [ json.dumps( details ).encode('UTF-8') ]
        else:
            raise RESTException(&quot;405 METHOD_NOT_ALLOWED&quot;,
                &quot;Method '{REQUEST_METHOD}' not allowed&quot;.format_map(environ))

    def bet_app( self, environ, start_response ):
        if environ['REQUEST_METHOD'] == 'GET':
            details = dict( self.table.bets )
        elif environ['REQUEST_METHOD'] == 'POST':
            size= int(environ['CONTENT_LENGTH'])
            raw= environ['wsgi.input'].read(size).decode(&quot;UTF-8&quot;)
            try:
                data = json.loads( raw )
                if isinstance(data,dict): data= [data]
                for detail in data:
                    self.table.place_bet( detail['bet'], int(detail['amount']) )
            except Exception as e:
                # Must undo all bets.
                raise RESTException(&quot;403 FORBIDDEN&quot;, &quot;Bet {raw!r}&quot;.format(raw=raw))
            details = dict( self.table.bets )
        else:
            raise RESTException(&quot;405 METHOD_NOT_ALLOWED&quot;,
                &quot;Method '{REQUEST_METHOD}' not allowed&quot;.format_map(environ))
        status = '200 OK'
        headers = [('Content-type', 'application/json; charset=utf-8')]
        start_response(status, headers)
        return [ json.dumps(details).encode('UTF-8') ]

    def wheel_app( self, environ, start_response ):
        if environ['REQUEST_METHOD'] == 'POST':
            size= environ['CONTENT_LENGTH']
            if size != '':
                raw= environ['wsgi.input'].read(int(size))
                raise RESTException(&quot;403 FORBIDDEN&quot;,
                    &quot;Data '{raw!r}' not allowed&quot;.format(raw=raw))
            spin= self.wheel.spin()
            payout = self.table.resolve( spin )
            self.rounds += 1
            details = dict( spin=spin, payout=payout, stake= self.table.stake, rounds= self.rounds )
            status = '200 OK'
            headers = [('Content-type', 'application/json; charset=utf-8')]
            start_response(status, headers)
            return [ json.dumps( details ).encode('UTF-8') ]
        else:
            raise RESTException(&quot;405 METHOD_NOT_ALLOWED&quot;,
                &quot;Method '{REQUEST_METHOD}' not allowed&quot;.format_map(environ))
</pre>
<p>Quick unit-test-like demonstration</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    # Spike to show that the essential features work.
    wheel= American()
    roulette= Roulette(wheel)
    data={'bet':'Black', 'amount':2}
    roulette.table.place_bet( data['bet'], int(data['amount']) )
    print( roulette.table.bets )
    spin= wheel.spin()
    payout = roulette.table.resolve( spin )
    print( spin, payout )
</pre>
<p>Server</p>
<pre class="literal-block">
def roulette_server_3(count=1):
    from wsgiref.simple_server import make_server
    from wsgiref.validate import validator
    wheel= American()
    roulette= Roulette(wheel)
    debug= validator(roulette)
    httpd = make_server('', 8080, debug)
    if count is None:
        httpd.serve_forever()
    else:
        for c in range(count):
            httpd.handle_request()
</pre>
<p>Client</p>
<pre class="literal-block">
import http.client
import json
def roulette_client(method=&quot;GET&quot;, path=&quot;/&quot;, data=None):
    rest= http.client.HTTPConnection('localhost', 8080)
    if data:
        header= {&quot;Content-type&quot;: &quot;application/json; charset=utf-8'&quot;}
        params= json.dumps( data ).encode('UTF-8')
        rest.request(method, path, params, header)
    else:
        rest.request(method, path)
    response= rest.getresponse()
    raw= response.read().decode(&quot;utf-8&quot;)
    if 200 &lt;= response.status &lt; 300:
        document= json.loads(raw)
        return document
    else:
        print( response.status, response.reason )
        print( response.getheaders() )
        print( raw )
</pre>
<p>Demo</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    import concurrent.futures
    import time
    with concurrent.futures.ProcessPoolExecutor() as executor:
        executor.submit( roulette_server_3, 4 )
        time.sleep(3) # Wait for the server to start
        print( roulette_client(&quot;GET&quot;, &quot;/player/&quot; ) )
        print( roulette_client(&quot;POST&quot;, &quot;/bet/&quot;, {'bet':'Black', 'amount':2}) )
        print( roulette_client(&quot;GET&quot;, &quot;/bet/&quot; ) )
        print( roulette_client(&quot;POST&quot;, &quot;/wheel/&quot; ) )
</pre>
</div>
<div class="section" id="rest-with-authentication">
<h2><a class="toc-backref" href="#id8">4.2&nbsp;&nbsp;&nbsp;REST with authentication</a></h2>
<p>Authentication class definition with password hashing.</p>
<pre class="literal-block">
from hashlib import sha256
import os
class Authentication:
    iterations= 1000
    def __init__( self, username, password ):
        &quot;&quot;&quot;Works with bytes. Not Unicode strings.&quot;&quot;&quot;
        self.username= username
        self.salt= os.urandom(24)
        self.hash= self._iter_hash( self.iterations, self.salt, username, password )
    &#64;staticmethod
    def _iter_hash( iterations, salt, username, password ):
        seed= salt+b&quot;:&quot;+username+b&quot;:&quot;+password
        for i in range(iterations):
            seed= sha256( seed ).digest()
        return seed
    def __eq__( self, other ):
        return self.username == other.username and self.hash == other.hash
    def __hash__( self, other ):
        return hash(self.hash)
    def __repr__( self ):
        salt_x= &quot;&quot;.join( &quot;{0:x}&quot;.format(b) for b in self.salt )
        hash_x= &quot;&quot;.join( &quot;{0:x}&quot;.format(b) for b in self.hash )
        return &quot;{username} {iterations:d}:{salt}:{hash}&quot;.format(
            username=self.username, iterations=self.iterations,
            salt=salt_x, hash=hash_x)
    def match( self, password ):
        test= self._iter_hash( self.iterations, self.salt, self.username, password )
        return self.hash == test # Constant Time is Best
</pre>
<p>Collection of users.</p>
<pre class="literal-block">
class Users( dict ):
    def __init__( self, *args, **kw ):
        super().__init__( *args, **kw )
        # Can never match -- keys are the same.
        self[&quot;&quot;]= Authentication( b&quot;__dummy__&quot;, b&quot;Doesn't Matter&quot; )
    def add( self, authentication ):
        if authentication.username == &quot;&quot;:
            raise KeyError( &quot;Invalid Authentication&quot; )
        self[authentication.username]= authentication
    def match( self, username, password ):
        if username in self and username != &quot;&quot;:
            return self[username].match(password)
        else:
            return self[&quot;&quot;].match(b&quot;Something which doesn't match&quot;)
</pre>
<p>Global Objects</p>
<pre class="literal-block">
users = Users()
users.add( Authentication(b&quot;Aladdin&quot;, b&quot;open sesame&quot;) )
</pre>
<p>Quick Demo</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    print( &quot;&gt;&gt;&gt; Authenticate as dummy 1:&quot;, users.match( &quot;&quot;,  b&quot;Doesn't Matter&quot; ) )
    print( &quot;&gt;&gt;&gt; Authenticate as dummy 2:&quot;, users.match( b&quot;__dummy__&quot;,  b&quot;Doesn't Matter&quot; ) )
</pre>
<p>Authentication app</p>
<pre class="literal-block">
import base64
class Authenticate( WSGI ):
    def __init__( self, users, target_app ):
        self.users= users
        self.target_app= target_app
    def __call__( self, environ, start_response ):
        if 'HTTP_AUTHORIZATION' in environ:
            scheme, credentials = environ['HTTP_AUTHORIZATION'].split()
            if scheme == &quot;Basic&quot;:
                username, password= base64.b64decode( credentials ).split(b&quot;:&quot;)
                if self.users.match(username, password):
                    environ['Authenticate.username']= username
                    return self.target_app(environ, start_response)
        status = '401 UNAUTHORIZED'
        headers = [('Content-type', 'text/plain; charset=utf-8'),
            ('WWW-Authenticate', 'Basic realm=&quot;roulette&#64;localhost&quot;')]
        start_response(status, headers)
        return [ &quot;Not authorized&quot;.encode('utf-8') ]
</pre>
<p>Some app which requires authentication</p>
<pre class="literal-block">
class Some_App( WSGI ):
    def __call__( self, environ, start_response ):
        status = '200 OK'
        headers = [('Content-type', 'text/plain; charset=utf-8')]
        start_response(status, headers)
        return [ &quot;Welcome&quot;.encode('UTF-8') ]
</pre>
<p>Demo client</p>
<pre class="literal-block">
import base64
def authenticated_client(method=&quot;GET&quot;, path=&quot;/&quot;, data=None, username=&quot;&quot;, password=&quot;&quot;):
    rest= http.client.HTTPConnection('localhost', 8080)
    headers= {}
    if username and password:
        enc= base64.b64encode( username.encode('ascii')+b&quot;:&quot;+password.encode('ascii') )
        headers[&quot;Authorization&quot;]= b&quot;Basic &quot;+enc
    if data:
        headers[&quot;Content-type&quot;]= &quot;application/json; charset=utf-8&quot;
        params= json.dumps( data ).encode('utf-8')
        rest.request(method, path, params, headers=headers)
    else:
        rest.request(method, path, headers=headers)
    response= rest.getresponse()
    raw= response.read().decode(&quot;utf-8&quot;)
    if response.status == 401:
        print( response.getheaders() )
    return response.status, response.reason, raw
</pre>
<p>Server</p>
<pre class="literal-block">
def auth_server(count=1):
    from wsgiref.simple_server import make_server
    from wsgiref.validate import validator
    secure_app= Some_App()
    authenticated_app= Authenticate(users, secure_app)
    debug= validator(authenticated_app)
    httpd = make_server('', 8080, debug)
    if count is None:
        httpd.serve_forever()
    else:
        for c in range(count):
            httpd.handle_request()
</pre>
<p>Demo</p>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:
    import concurrent.futures
    import time
    with concurrent.futures.ProcessPoolExecutor() as executor:
        executor.submit( auth_server, 3 )
        time.sleep(3) # Wait for the server to start
        print( authenticated_client(&quot;GET&quot;, &quot;/player/&quot;, ) )
        print( authenticated_client(&quot;GET&quot;, &quot;/player/&quot;, username=&quot;Aladdin&quot;, password=&quot;open sesame&quot;, ) )
        print( authenticated_client(&quot;GET&quot;, &quot;/player/&quot;, username=&quot;Aladdin&quot;, password=&quot;not right&quot;, ) )
</pre>
</div>
<div class="section" id="multiprocessing-example">
<h2><a class="toc-backref" href="#id9">4.3&nbsp;&nbsp;&nbsp;Multiprocessing Example</a></h2>
<p>Import the simulation model...</p>
<pre class="literal-block">
from simulation_model import *

import multiprocessing
</pre>
<p>We want a Simulation process to cough up some statistics</p>
<pre class="literal-block">
class Simulation( multiprocessing.Process ):
    def __init__( self, setup_queue, result_queue ):
        self.setup_queue= setup_queue
        self.result_queue= result_queue
        super().__init__()
    def run( self ):
        &quot;&quot;&quot;Waits for a termination&quot;&quot;&quot;
        print( self.__class__.__name__, &quot;start&quot; )
        item= self.setup_queue.get()
        while item != (None,None):
            table, player = item
            self.sim= Simulate( table, player, samples=1 )
            results= list( self.sim )
            self.result_queue.put( (table, player, results[0]) )
            item= self.setup_queue.get()
        print( self.__class__.__name__, &quot;finish&quot; )
</pre>
<p>We want a Summarization process to gather and summarize all those stats.</p>
<pre class="literal-block">
class Summarize( multiprocessing.Process ):
    def __init__( self, queue ):
        self.queue= queue
        super().__init__()
    def run( self ):
        &quot;&quot;&quot;Waits for a termination&quot;&quot;&quot;
        print( self.__class__.__name__, &quot;start&quot; )
        count= 0
        item= self.queue.get()
        while item != (None,None,None):
            print( item )
            count += 1
            item= self.queue.get()
        print( self.__class__.__name__, &quot;finish&quot;, count )
</pre>
</div>
</div>
<div class="section" id="create-and-run-the-simulation">
<h1><a class="toc-backref" href="#id10">5&nbsp;&nbsp;&nbsp;Create and run the simulation</a></h1>
<pre class="literal-block">
if __name__ == &quot;__main__&quot;:

    # Two queues
    # ::

    setup_q= multiprocessing.SimpleQueue()
    results_q= multiprocessing.SimpleQueue()

    # The summarization process: waiting for work
    # ::

    result= Summarize( results_q )
    result.start()

    # The simulation process: also waiting for work.
    # We might want to create a Pool of these so that
    # we can get even more done at one time.
    # ::

    simulators= []
    for i in range(4):
        sim= Simulation( setup_q, results_q )
        sim.start()
        simulators.append( sim )

    # Queue up some objects to work on.
    # ::

    table= Table( decks= 6, limit= 50, dealer=Hit17(),
        split= ReSplit(), payout=(3,2) )
    for bet in Flat, Martingale, OneThreeTwoSix:
        player= Player( SomeStrategy, bet(), 100, 25 )
        for sample in range(5):
            setup_q.put( (table, player) )

    # Queue a terminator for each simulator.
    # ::

    for sim in simulators:
        setup_q.put( (None,None) )

    # Wait for the simulations to all finish.
    # ::

    for sim in simulators:
        sim.join()

    # Queue up a results terminator.
    # Results processing done?
    # ::

    results_q.put( (None,None,None) )
    result.join()
    del results_q
    del setup_q
</pre>
</div>
</div>
</body>
</html>
