<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.9: http://docutils.sourceforge.net/" />
<title>Chapter 1 -- The __init__() Method</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7056 2011-06-17 10:50:48Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math {
  margin-left: 2em ;
  margin-right: 2em }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
<style type="text/css">

/* example stylesheet for Docutils */

/* :Author:    Günter Milde */
/* :Copyright: © 2012 G. Milde */
/* :License:   This stylesheet is placed in the public domain. */

/* Syntax highlight rules for HTML documents generated with Docutils */
/* using the ``--syntax-highlight=long`` option (new in v. 0.9). */

/* This stylesheet implements Pygment's "default" style with less rules than */
/* pygments-default using class hierarchies.                                 */
/* Use it as example for "handcrafted" styles with only few rules.      */

.code                              { background: #f8f8f8; }
.code .comment                     { color: #008800; font-style: italic }
.code .error                       { border: 1px solid #FF0000 }
.code .generic.deleted             { color: #A00000 }
.code .generic.emph                { font-style: italic }
.code .generic.error               { color: #FF0000 }
.code .generic.heading             { color: #000080; font-weight: bold }
.code .generic.inserted            { color: #00A000 }
.code .generic.output              { color: #808080 }
.code .generic.prompt              { color: #000080; font-weight: bold }
.code .generic.strong              { font-weight: bold }
.code .generic.subheading          { color: #800080; font-weight: bold }
.code .generic.traceback           { color: #0040D0 }
.code .keyword                     { color: #AA22FF; font-weight: bold }
.code .keyword.pseudo              { font-weight: normal }
.code .literal.number              { color: #666666 }
.code .literal.string              { color: #BB4444 }
.code .literal.string.doc          { color: #BB4444; font-style: italic }
.code .literal.string.escape       { color: #BB6622; font-weight: bold }
.code .literal.string.interpol     { color: #BB6688; font-weight: bold }
.code .literal.string.other        { color: #008000 }
.code .literal.string.regex        { color: #BB6688 }
.code .literal.string.symbol       { color: #B8860B }
.code .name.attribute              { color: #BB4444 }
.code .name.builtin                { color: #AA22FF }
.code .name.class                  { color: #0000FF }
.code .name.constant               { color: #880000 }
.code .name.decorator              { color: #AA22FF }
.code .name.entity                 { color: #999999; font-weight: bold }
.code .name.exception              { color: #D2413A; font-weight: bold }
.code .name.function               { color: #00A000 }
.code .name.label                  { color: #A0A000 }
.code .name.namespace              { color: #0000FF; font-weight: bold }
.code .name.tag                    { color: #008000; font-weight: bold }
.code .name.variable               { color: #B8860B }
.code .operator                    { color: #666666 }
.code .operator.word               { color: #AA22FF; font-weight: bold }

</style>
<style type="text/css">

/* Page layout tweaks */
div.document { width: 6in; }

</style>
</head>
<body>
<div class="document" id="chapter-1-the-init-method">
<h1 class="title">Chapter 1 -- The <tt class="docutils literal">__init__()</tt> Method</h1>

<!-- #!/usr/bin/env python3 -->
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="auto-toc simple">
<li><a class="reference internal" href="#simple-objects-cards" id="id1">1&nbsp;&nbsp;&nbsp;Simple Objects: Cards</a></li>
<li><a class="reference internal" href="#alternative-designs-for-the-initialization" id="id2">2&nbsp;&nbsp;&nbsp;Alternative Designs for the Initialization</a></li>
<li><a class="reference internal" href="#composite-objects-deck" id="id3">3&nbsp;&nbsp;&nbsp;Composite Objects: Deck</a></li>
<li><a class="reference internal" href="#composite-objects-hand" id="id4">4&nbsp;&nbsp;&nbsp;Composite Objects: Hand</a></li>
<li><a class="reference internal" href="#composite-objects-betting-strategy" id="id5">5&nbsp;&nbsp;&nbsp;Composite Objects: Betting Strategy</a></li>
<li><a class="reference internal" href="#bad-ideas" id="id6">6&nbsp;&nbsp;&nbsp;Bad Ideas</a></li>
</ul>
</div>
<div class="section" id="simple-objects-cards">
<h1><a class="toc-backref" href="#id1">1&nbsp;&nbsp;&nbsp;Simple Objects: Cards</a></h1>
<p>Definition of a simple class hierarchy</p>
<pre class="literal-block">
class Card:
    insure= False
    def  __init__( self, rank, suit ):
        self.suit= suit
        self.rank= rank
        self.hard, self.soft = self._points()
    def __eq__( self, other ):
        return self.suit == other.suit and self.rank == other.rank and self.hard == other.hard and self.soft == other.soft
    def __repr__( self ):
        return &quot;{__class__.__name__}(suit={suit!r}, rank={rank!r})&quot;.format(__class__=self.__class__, **self.__dict__)
    def __str__( self ):
        return &quot;{rank}{suit}&quot;.format(**self.__dict__)
class NumberCard( Card ):
    def _points( self ):
        return int(self.rank), int(self.rank)
class AceCard( Card ):
    insure= True
    def _points( self ):
        return 1, 11
class FaceCard( Card ):
    def _points( self ):
        return 10, 10
</pre>
<p>We can create cards like this</p>
<pre class="literal-block">
d1= [ AceCard('A', '♠'), NumberCard('2','♠'), NumberCard('3','♠'), ]
</pre>
<p>A simple class from which we can build manifest constants</p>
<pre class="literal-block">
class Suit:
    def __init__( self, name, symbol ):
        self.name= name
        self.symbol= symbol
    def __repr__( self ):
        return self.symbol
</pre>
<p>Some &quot;constants&quot;</p>
<pre class="literal-block">
Club, Diamond, Heart, Spade = Suit('Club','♣'), Suit('Diamond','♦'), Suit('Heart','♥'), Suit('Spade','♠')
</pre>
<p>We can create cards like this</p>
<pre class="literal-block">
d2 = [ AceCard('A', Spade), NumberCard('2', Spade), NumberCard('3', Spade), ]
</pre>
<p>Factory Function</p>
<pre class="literal-block">
def card( rank, suit ):
    if rank == 1: return AceCard( 'A', suit )
    elif 2 &lt;= rank &lt; 11: return NumberCard( str(rank), suit )
    elif 11 &lt;= rank &lt; 14:
        name = { 11: 'J', 12: 'Q', 13: 'K' }[rank]
        return FaceCard( name, suit )
    raise Exception( &quot;Design Failure&quot; )
</pre>
<p>This function builds a Card from a numeric rank and a Suit object. We can now # build cards very simply.</p>
<pre class="literal-block">
deck = [ card(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
</pre>
<p>Here's a less desirable form of the factory function.
It harbors a hidden bug because the else assumes too much.</p>
<pre class="literal-block">
def card2( rank, suit ):
    if rank == 1: return AceCard( 'A', suit )
    elif 2 &lt;= rank &lt; 11: return NumberCard( str(rank), suit )
    else:
        name = { 11: 'J', 12: 'Q', 13: 'K' }[rank]
        return FaceCard( name, suit )

try:
    deck2 = [ card2(rank,suit) for rank in range(13) for suit in (Club, Diamond, Heart, Spade) ]
except KeyError:
    pass # print( &quot;card2 didn't work&quot; )
</pre>
<p>Here's a more consistent factory function that doesn't mix elif and a mapping.</p>
<pre class="literal-block">
def card3( rank, suit ):
    if rank == 1: return AceCard( 'A', suit )
    elif 2 &lt;= rank &lt; 11: return NumberCard( str(rank), suit )
    elif rank == 11:
        return FaceCard( 'J', suit )
    elif rank == 12:
        return FaceCard( 'Q', suit )
    elif rank == 13:
        return FaceCard( 'K', suit )
    else:
        raise Exception( &quot;Rank out of range&quot; )

deck3 = [ card3(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
assert deck3 == deck
</pre>
<p>Here's an incomplete, but more consistent factory that uses just a mapping.
This doesn't properly translate rank to a string.</p>
<pre class="literal-block">
def card4( rank, suit ):
    class_= {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard }.get(rank, NumberCard)
    return class_( rank, suit )

deck4 = [ card4(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
try:
    assert deck4 == deck
    raise Exception( &quot;Should not match!&quot; )
except AssertionError:
    pass # Not the same
</pre>
<p>Here's the two-parallel mapping version.</p>
<pre class="literal-block">
def card5( rank, suit ):
    class_= {1: AceCard, 11: FaceCard, 12: FaceCard, 13: FaceCard }.get(rank, NumberCard)
    rank_str= {1:'A', 11:'J', 12:'Q', 13:'K'}.get(rank,str(rank))
    return class_( rank_str, suit )

deck5 = [ card5(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
assert deck5 == deck
</pre>
<p>Here's the mapping two a 2-tuple version.</p>
<pre class="literal-block">
def card6( rank, suit ):
    class_, rank_str= {
        1:(AceCard,'A'),
        11:(FaceCard,'J'),
        12:(FaceCard,'Q'),
        13:(FaceCard,'K'),
        }.get(rank, (NumberCard, str(rank)))
    return class_( rank_str, suit )

deck6 = [ card6(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
assert deck6 == deck
</pre>
<p>Here's the mapping to a partial version.</p>
<pre class="literal-block">
from functools import partial
def card7( rank, suit ):
    part_class= {
        1:partial(AceCard,'A'),
        11:partial(FaceCard,'J'),
        12:partial(FaceCard,'Q'),
        13: partial(FaceCard,'K'),
        }.get(rank, partial(NumberCard,str(rank)))
    return part_class( suit )

deck7 = [ card7(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
assert deck7 == deck
</pre>
<p>Here's a stateful card factory that's isomorphic to a partial.</p>
<pre class="literal-block">
class CardFactory:
    def rank( self, rank ):
        self.class_, self.rank_str= {
            1:(AceCard,'A'),
            11:(FaceCard,'J'),
            12:(FaceCard,'Q'),
            13:(FaceCard,'K'),
            }.get(rank, (NumberCard, str(rank)))
        return self
    def suit( self, suit ):
        return self.class_( self.rank_str, suit )

card8 = CardFactory()
deck8 = [ card8.rank(r+1).suit(s) for r in range(13) for s in (Club, Diamond, Heart, Spade) ]
assert deck8 == deck
</pre>
</div>
<div class="section" id="alternative-designs-for-the-initialization">
<h1><a class="toc-backref" href="#id2">2&nbsp;&nbsp;&nbsp;Alternative Designs for the Initialization</a></h1>
<p>Subclass only</p>
<pre class="literal-block">
class Card2:
    def __eq__( self, other ):
        return self.suit == other.suit and self.rank == other.rank and self.hard == other.hard and self.soft == other.soft
    def __repr__( self ):
        return &quot;suit={suit!r}, rank={rank!r}, hard={hard!r}, soft={soft!r}&quot;.format(**self.__dict__)
class NumberCard2( Card2 ):
    def  __init__( self, rank, suit ):
        self.suit= suit
        self.rank= str(rank)
        self.hard = self.soft = rank
class AceCard2( Card2 ):
    def  __init__( self, rank, suit ):
        self.suit= suit
        self.rank= &quot;A&quot;
        self.hard, self.soft =  1, 11
class FaceCard2( Card2 ):
    def  __init__( self, rank, suit ):
        self.suit= suit
        self.rank= {11: 'J', 12: 'Q', 13: 'K' }[rank]
        self.hard = self.soft = 10

def card9( rank, suit ):
    if rank == 1: return AceCard2( rank, suit )
    elif 2 &lt;= rank &lt; 11: return NumberCard2( rank, suit )
    elif 11 &lt;= rank &lt; 14: return FaceCard2( rank, suit )
    else:
        raise Exception( &quot;Rank out of range&quot; )

deck9 = [ card9(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
for c9, c in zip( deck9, deck ):
    assert c9 == c, &quot;{0!r} != {1!r}&quot;.format(c9,c)
assert deck9 == deck
</pre>
<p>Mixed subclass and superclass.</p>
<pre class="literal-block">
class Card3:
    def __init__( self, rank, suit, hard, soft ):
        self.rank= rank
        self.suit= suit
        self.hard= hard
        self.soft= soft
    def __eq__( self, other ):
        return self.suit == other.suit and self.rank == other.rank and self.hard == other.hard and self.soft == other.soft
class NumberCard3( Card3 ):
    def  __init__( self, rank, suit ):
        super().__init__( str(rank), suit, rank, rank )
class AceCard3( Card3 ):
    def  __init__( self, rank, suit ):
        super().__init__( &quot;A&quot;, suit, 1, 11 )
class FaceCard3( Card3 ):
    def  __init__( self, rank, suit ):
        super().__init__( {11: 'J', 12: 'Q', 13: 'K' }[rank], suit, 10, 10 )

def card10( rank, suit ):
    if rank == 1: return AceCard3( rank, suit )
    elif 2 &lt;= rank &lt; 11: return NumberCard3( rank, suit )
    elif 11 &lt;= rank &lt; 14: return FaceCard3( rank, suit )
    else:
        raise Exception( &quot;Rank out of range&quot; )

deck10 = [ card10(rank,suit) for rank in range(1,14) for suit in (Club, Diamond, Heart, Spade) ]
assert deck10 == deck
</pre>
</div>
<div class="section" id="composite-objects-deck">
<h1><a class="toc-backref" href="#id3">3&nbsp;&nbsp;&nbsp;Composite Objects: Deck</a></h1>
<p>Need this</p>
<pre class="literal-block">
import random
</pre>
<p>A simple Deck definition</p>
<pre class="literal-block">
class Deck:
    def __init__( self ):
        self._cards = [ card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade) ]
        random.shuffle( self._cards )
    def pop( self ):
        return self._cards.pop()

d= Deck()
hand= [ d.pop(), d.pop() ]

print( hand )
</pre>
<p>A subclass of list definition</p>
<pre class="literal-block">
class Deck2( list ):
    def __init__( self ):
        super().__init__( card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade) )
        random.shuffle( self )

d= Deck2()
hand= [ d.pop(), d.pop() ]

print( hand )
</pre>
<p>A better subclass of list which has the necessary additional features of
multiple sets of cards plus not dealing the entire deck.</p>
<pre class="literal-block">
class Deck3(list):
    def __init__(self, decks=1):
        super().__init__()
        for i in range(decks):
            self.extend( card6(r+1,s) for r in range(13) for s in (Club, Diamond, Heart, Spade) )
        random.shuffle( self )
        burn= random.randint(1,52)
        for i in range(burn): self.pop()

d= Deck3()
hand= [ d.pop(), d.pop() ]

print( hand )
</pre>
</div>
<div class="section" id="composite-objects-hand">
<h1><a class="toc-backref" href="#id4">4&nbsp;&nbsp;&nbsp;Composite Objects: Hand</a></h1>
<p>A simplistic Hand without a proper initialization of the cards.</p>
<pre class="literal-block">
class Hand:
    def __init__( self, dealer_card ):
        self.dealer_card= dealer_card
        self.cards= []
    def hard_total(self ):
        return sum(c.hard for c in self.cards)
    def soft_total(self ):
        return sum(c.soft for c in self.cards)

d = Deck()
h = Hand( d.pop() )
h.cards.append( d.pop() )
h.cards.append( d.pop() )
</pre>
<p>A Better Hand with a complete initialization of the cards.
This works better with serialization.</p>
<pre class="literal-block">
class Hand2:
    def __init__( self, dealer_card, *cards ):
        self.dealer_card= dealer_card
        self.cards = list(cards)
    def card_append( self, card ):
        self.cards.append( card )
    def hard_total(self ):
        return sum(c.hard for c in self.cards)
    def soft_total(self ):
        return sum(c.soft for c in self.cards)

d = Deck()
h = Hand2( d.pop(), d.pop(), d.pop() )
</pre>
<p>A Hand which can be built from another hand. This allows us to freeze
the hand or build a memento version of the hand.</p>
<pre class="literal-block">
class Hand3:
    def __init__( self, *args, **kw ):
        if len(args) == 1 and isinstance(args[0],Hand3):
            # Clone an existing hand
            other= args[0]
            self.dealer_card= other.dealer_card
            self.cards= other.cards
        else:
            # Build a fresh, new hand.
            dealer_card, *cards = args
            self.dealer_card=  dealer_card
            self.cards= list(cards)

d = Deck()
h = Hand3( d.pop(), d.pop(), d.pop() )
memento = Hand3( h )
</pre>
<p>A Hand which can be built from another hand. This can also be used to
split a hand.</p>
<pre class="literal-block">
class Hand4:
    def __init__( self, *args, **kw ):
        if len(args) == 1 and isinstance(args[0],Hand4):
            # Clone an existing hand
            other= args[0]
            self.dealer_card= other.dealer_card
            self.cards= other.cards
        elif len(args) == 2 and isinstance(args[0],Hand4) and 'split' in kw:
            # Split an existing hand
            other, card= args
            self.dealer_card= other.dealer_card
            self.cards= [other.cards[kw['split']], card]
        elif len(args) == 3:
            # Build a fresh, new hand.
            dealer_card, *cards = args
            self.dealer_card=  dealer_card
            self.cards= list(cards)
        else:
            raise TypeError( &quot;Invalid constructor args={0!r} kw={1!r}&quot;.format(args, kw) )
    def __str__( self ):
        return &quot;, &quot;.join( map(str, self.cards) )

d = Deck()
h = Hand4( d.pop(), d.pop(), d.pop() )
s1 = Hand4( h, d.pop(), split=0 )
s2 = Hand4( h, d.pop(), split=1 )
print( &quot;start&quot;, h, &quot;split1&quot;, s1, &quot;split2&quot;, s2 )
</pre>
<p>A Hand with static methods to split or frozen as a memento.</p>
<pre class="literal-block">
class Hand5:
    def __init__( self, dealer_card, *cards ):
        self.dealer_card= dealer_card
        self.cards = list(cards)
    &#64;staticmethod
    def freeze( other ):
        hand= Hand5( other.dealer_card, *other.cards )
        return hand
    &#64;staticmethod
    def split( other, card0, card1 ):
        hand0= Hand5( other.dealer_card, other.cards[0], card0 )
        hand1= Hand5( other.dealer_card, other.cards[1], card1 )
        return hand0, hand1
    def __str__( self ):
        return &quot;, &quot;.join( map(str, self.cards) )

d = Deck()
h = Hand5( d.pop(), d.pop(), d.pop() )
s1, s2 = Hand5.split( h, d.pop(), d.pop() )
print( &quot;start&quot;, h, &quot;split1&quot;, s1, &quot;split2&quot;, s2 )
</pre>
</div>
<div class="section" id="composite-objects-betting-strategy">
<h1><a class="toc-backref" href="#id5">5&nbsp;&nbsp;&nbsp;Composite Objects: Betting Strategy</a></h1>
<p>A strategy class hierarchy for Betting.</p>
<pre class="literal-block">
class BettingStrategy:
    def bet( self ):
        raise NotImplementedError( &quot;No bet method&quot; )
    def record_win( self ):
        pass
    def record_loss( self ):
        pass

class Flat(BettingStrategy):
    def bet( self ):
        return 1

flat_bet= Flat()

flat_bet.bet()

import abc
from abc import abstractmethod
class BettingStrategy2(metaclass=abc.ABCMeta):
    &#64;abstractmethod
    def bet( self ):
        return 1
    def record_win( self ):
        pass
    def record_loss( self ):
        pass
</pre>
<p>A strategy class hierarchy for Play.</p>
<pre class="literal-block">
class GameStrategy:
    def insurance( self, hand ):
        return False
    def split( self, hand ):
        return False
    def double( self, hand ):
        return False
    def hit( self, hand ):
        return sum(c.hard for c in hand.cards) &lt;= 17

dumb = GameStrategy()
</pre>
<p>A simple outline for the Table.</p>
<pre class="literal-block">
class Table:
    def __init__( self ):
        self.deck = Deck()
    def place_bet( self, amount ):
        print( &quot;Bet&quot;, amount )
    def get_hand( self ):
        try:
            self.hand= Hand2( d.pop(), d.pop(), d.pop() )
            self.hole_card= d.pop()
        except IndexError:
            # Out of cards: need to shuffle.
            # This is not technically correct.
            self.deck= Deck()
            return self.get_hand()
        print( &quot;Deal&quot;, self.hand )
        return self.hand
    def can_insure( self, hand ):
        return hand.dealer_card.insure
</pre>
<p>A Player definition</p>
<pre class="literal-block">
class Player:
    def __init__( self, table, bet_strategy, game_strategy ):
        self.bet_strategy = bet_strategy
        self.game_strategy = game_strategy
        self.table= table
    def game( self ):
        self.table.place_bet( self.bet_strategy.bet() )
        self.hand= self.table.get_hand()
        if self.table.can_insure( self.hand ):
            if self.game_strategy.insurance( self.hand ):
                self.table.insure( self.bet_strategy.bet() )
        # etc.
</pre>
<p>Typical Use Case</p>
<pre class="literal-block">
table = Table()
flat_bet= Flat()
dumb = GameStrategy()
p = Player( table, flat_bet, dumb )
p.game()
</pre>
<p>A Player definition using wide-open keyword definitions.</p>
<pre class="literal-block">
class Player2( Player ):
    def __init__( self, **kw ):
        &quot;&quot;&quot;Must provide table, bet_strategy, game_strategy.&quot;&quot;&quot;
        self.__dict__.update( kw )
    def game( self ):
        self.table.place_bet( self.bet_strategy.bet() )
        self.hand= self.table.get_hand()
</pre>
<p>Typical Use Case.</p>
<pre class="literal-block">
table = Table()
flat_bet= Flat()
dumb = GameStrategy()
p1 = Player2( table=table, bet_strategy=flat_bet, game_strategy=dumb )
p1.game()
</pre>
<p>Bonus Use Case. Set an additional attribute.</p>
<pre class="literal-block">
p2 = Player2( table=table, bet_strategy=flat_bet, game_strategy=dumb, log_name=&quot;Flat/Dumb&quot; )
p2.game()
print( p2.log_name, p2.hand )
</pre>
<p>A Player definition using wide-open keyword definitions.</p>
<pre class="literal-block">
class Player3( Player ):
    def __init__( self, table, bet_strategy, game_strategy, **extras ):
        self.bet_strategy = bet_strategy
        self.game_strategy = game_strategy
        self.table= table
        self.__dict__.update( extras )

table = Table()
flat_bet= Flat()
dumb = GameStrategy()
p3 = Player3( table, flat_bet, dumb, log_name=&quot;Flat/Dumb&quot; )
p3.game()
print( p3.log_name, p3.hand )
</pre>
</div>
<div class="section" id="bad-ideas">
<h1><a class="toc-backref" href="#id6">6&nbsp;&nbsp;&nbsp;Bad Ideas</a></h1>
<p>Validation</p>
<pre class="literal-block">
class ValidPlayer:
    def __init__( self, table, bet_strategy, game_strategy ):
        assert isinstance( table, Table )
        assert isinstance( bet_strategy, BettingStrategy )
        assert isinstance( game_strategy, GameStrategy )

        self.bet_strategy = bet_strategy
        self.game_strategy = game_strategy
        self.table= table

table = Table()
flat_bet= Flat()
dumb = GameStrategy()
p4= ValidPlayer( table, flat_bet, dumb )

class Player:
    def __init__( self, table, bet_strategy, game_strategy ):
        &quot;&quot;&quot;Creates a new player associated with a table, and configured with
        proper betting and play strategies

        :param table: an instance of :class:`Table`
        :param bet_strategy: an instance of :class:`BettingStrategy`
        :param  game_strategy: an instance of :class:`GameStrategy`
        &quot;&quot;&quot;
        self.bet_strategy = bet_strategy
        self.game_strategy = game_strategy
        self.table= table
</pre>
</div>
</div>
</body>
</html>
